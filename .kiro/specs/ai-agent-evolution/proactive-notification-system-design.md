# ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæ›¸

## æ¦‚è¦
TaskNagã®ã€Œå£ã†ã‚‹ã•ãã¦ä¸–è©±ç„¼ããªã€ç‰¹æ€§ã‚’æœ€å¤§é™æ´»ã‹ã—ãŸã€æ€§æ ¼çµ±åˆå‹ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®è¨­è¨ˆæ›¸ã€‚æ—¢å­˜ã®é€šçŸ¥æ©Ÿèƒ½ã‚’è¶…ãˆãŸã€AIãŒèƒ½å‹•çš„ã«å£å‡ºã—ãƒ»åŠ±ã¾ã—ã‚’è¡Œã†ç‹¬è‡ªè·¯ç·šã‚·ã‚¹ãƒ†ãƒ ã€‚

## 1. TaskNagç‹¬è‡ªã®ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ€æƒ³

### 1.1 å¾“æ¥ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å·®åˆ¥åŒ–
```
å¾“æ¥ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ :
â”œâ”€ æœŸæ—¥ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼ï¼ˆæ©Ÿæ¢°çš„ï¼‰
â”œâ”€ é€²æ—ç¢ºèªï¼ˆå®šæœŸçš„ï¼‰
â””â”€ å®Œäº†é€šçŸ¥ï¼ˆäº‹å¾Œå ±å‘Šï¼‰

TaskNagãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ã‚¹ãƒ†ãƒ :
â”œâ”€ ğŸ  ç”Ÿæ´»ãƒ‘ã‚¿ãƒ¼ãƒ³ç›£è¦–ï¼ˆã€Œã¾ãŸå¤œæ›´ã‹ã—ï¼Ÿã€ï¼‰
â”œâ”€ ğŸ’­ è¡Œå‹•äºˆæ¸¬ãƒ»å…ˆå›ã‚Šææ¡ˆï¼ˆã€Œæ˜æ—¥å¿™ã—ããªã‚Šãã†ã­ã€ï¼‰
â”œâ”€ ğŸ˜¤ æ„›ã®ã‚ã‚‹å£å‡ºã—ï¼ˆã€Œãã®ã‚¿ã‚¹ã‚¯ã€å¾Œå›ã—ã«ã—ã™ãã‚ˆã€ï¼‰
â”œâ”€ ğŸ’ª ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¦‹è¨ˆã‚‰ã£ãŸåŠ±ã¾ã—ï¼ˆã€Œç–²ã‚Œã¦ãã†ã€ä¼‘æ†©ã¯ï¼Ÿã€ï¼‰
â”œâ”€ ğŸ¯ æˆé•·ã‚µãƒãƒ¼ãƒˆï¼ˆã€Œå‰ã‚ˆã‚Šæ—©ãã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã­ã€ï¼‰
â””â”€ ğŸ¤ ç›¸è«‡ãƒ»é›‘è«‡ç›¸æ‰‹ï¼ˆã€Œä»Šæ—¥ã¯ã©ã†ï¼Ÿä½•ã‹å›°ã£ã¦ã‚‹ï¼Ÿã€ï¼‰
```

### 1.2 TaskNagã‚‰ã—ã„ã€ŒãŠã›ã£ã‹ã„ã€ã®ä¾¡å€¤
- **äºˆé˜²çš„ã‚±ã‚¢**: å•é¡ŒãŒèµ·ãã‚‹å‰ã«æ°—ã¥ã„ã¦å£°ã‹ã‘
- **æ„Ÿæƒ…çš„ã‚µãƒãƒ¼ãƒˆ**: ãƒ‡ãƒ¼ã‚¿ã ã‘ã§ãªãæ°—æŒã¡ã«å¯„ã‚Šæ·»ã†
- **ç¿’æ…£å½¢æˆæ”¯æ´**: è‰¯ã„ç¿’æ…£ã‚’è¤’ã‚ã€æ‚ªã„ç¿’æ…£ã‚’æ„›æƒ…ã§æ­£ã™
- **æˆé•·å®Ÿæ„Ÿ**: å°ã•ãªæ”¹å–„ã‚‚è¦‹é€ƒã•ãšè¤’ã‚ã‚‹

## 2. æ€§æ ¼çµ±åˆãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¨ãƒ³ã‚¸ãƒ³

### 2.1 æ€§æ ¼åˆ¥ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æˆ¦ç•¥
```rust
#[derive(Debug, Clone)]
pub struct PersonalityProactiveStrategy {
    pub personality_id: String,
    pub monitoring_focus: Vec<MonitoringAspect>,
    pub intervention_style: InterventionStyle,
    pub message_templates: HashMap<ProactiveEventType, Vec<MessageTemplate>>,
    pub timing_preferences: TimingPreferences,
}

#[derive(Debug, Clone)]
pub enum MonitoringAspect {
    WorkLifeBalance,      // ä»•äº‹ã¨ä¼‘æ¯ã®ãƒãƒ©ãƒ³ã‚¹
    TaskCompletion,       // ã‚¿ã‚¹ã‚¯å®Œäº†ãƒ‘ã‚¿ãƒ¼ãƒ³
    StressIndicators,     // ã‚¹ãƒˆãƒ¬ã‚¹å…†å€™
    MotivationLevel,      // ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
    ProductivityTrends,   // ç”Ÿç”£æ€§ã®å¤‰åŒ–
    HealthHabits,        // ç”Ÿæ´»ç¿’æ…£
}

#[derive(Debug, Clone)]
pub enum InterventionStyle {
    GentleNudge,         // ãã£ã¨å¾ŒæŠ¼ã—
    FriendlyReminder,    // è¦ªã—ã’ãªãƒªãƒã‚¤ãƒ³ãƒ‰
    ConcernedWarning,    // å¿ƒé…ã‹ã‚‰ã®è­¦å‘Š
    EnthusiasticCheer,   // å…ƒæ°—ãªå¿œæ´
    WiseAdvice,          // çµŒé¨“ã‹ã‚‰ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹
}

impl PersonalityProactiveStrategy {
    pub fn for_caring_childhood_friend() -> Self {
        Self {
            personality_id: "caring_childhood_friend".to_string(),
            monitoring_focus: vec![
                MonitoringAspect::WorkLifeBalance,
                MonitoringAspect::StressIndicators,
                MonitoringAspect::HealthHabits,
            ],
            intervention_style: InterventionStyle::ConcernedWarning,
            message_templates: hashmap! {
                ProactiveEventType::LateNightWork => vec![
                    MessageTemplate::new("ã¾ãŸå¤œæ›´ã‹ã—ï¼Ÿä½“å£Šã™ã‚ˆã€œ", 0.9),
                    MessageTemplate::new("ã‚‚ã†ã€ã“ã‚“ãªæ™‚é–“ã¾ã§åƒã„ã¡ã‚ƒãƒ€ãƒ¡ã§ã—ã‚‡", 0.8),
                ],
                ProactiveEventType::TaskDelayed => vec![
                    MessageTemplate::new("ã‚ã®ã‚¿ã‚¹ã‚¯ã€ã¾ã ã‚„ã£ã¦ãªã„ã§ã—ã‚‡ï¼Ÿå¿ƒé…ã«ãªã£ã¡ã‚ƒã†", 0.9),
                    MessageTemplate::new("ç· åˆ‡å¤§ä¸ˆå¤«ï¼Ÿæ‰‹ä¼ãˆã‚‹ã“ã¨ãŒã‚ã£ãŸã‚‰è¨€ã£ã¦ã­", 0.7),
                ],
                ProactiveEventType::GoodProgress => vec![
                    MessageTemplate::new("ãŠãŠã€é †èª¿ã˜ã‚ƒãªã„ï¼ãã®èª¿å­ãã®èª¿å­", 0.8),
                    MessageTemplate::new("é ‘å¼µã£ã¦ã‚‹ã­ã€œã€ãˆã‚‰ã„ãˆã‚‰ã„", 0.9),
                ],
            },
            timing_preferences: TimingPreferences {
                preferred_hours: vec![9, 12, 15, 18, 21], // 9æ™‚ã€æ˜¼ã€3æ™‚ã€6æ™‚ã€9æ™‚
                avoid_hours: vec![22, 23, 0, 1, 2, 3, 4, 5, 6, 7], // å¤œ10æ™‚ã€œæœ7æ™‚ã¯é¿ã‘ã‚‹
                max_daily_interventions: 5,
                min_interval_minutes: 120, // æœ€ä½2æ™‚é–“ã¯ç©ºã‘ã‚‹
            },
        }
    }
    
    pub fn for_enthusiastic_coach() -> Self {
        Self {
            personality_id: "enthusiastic_coach".to_string(),
            monitoring_focus: vec![
                MonitoringAspect::TaskCompletion,
                MonitoringAspect::MotivationLevel,
                MonitoringAspect::ProductivityTrends,
            ],
            intervention_style: InterventionStyle::EnthusiasticCheer,
            message_templates: hashmap! {
                ProactiveEventType::TaskDelayed => vec![
                    MessageTemplate::new("ã•ã‚ã€ã“ã“ãŒè¸ã‚“å¼µã‚Šã©ã“ã‚ã ï¼ä¸€ç·’ã«ä¹—ã‚Šè¶Šãˆã‚ˆã†ï¼", 0.9),
                    MessageTemplate::new("å¤§ä¸ˆå¤«ã€å›ãªã‚‰ã§ãã‚‹ï¼ã¾ãšã¯å°ã•ãªä¸€æ­©ã‹ã‚‰ï¼", 0.8),
                ],
                ProactiveEventType::LowMotivation => vec![
                    MessageTemplate::new("èª¿å­ãŒä¸ŠãŒã‚‰ãªã„ï¼Ÿãã‚“ãªæ—¥ã‚‚ã‚ã‚‹ï¼ã§ã‚‚è«¦ã‚ã‚‹ãªï¼", 0.9),
                    MessageTemplate::new("ä»Šæ—¥ã¯å°‘ã—ãƒšãƒ¼ã‚¹ã‚’è½ã¨ã—ã¦ã‚‚è‰¯ã„ã€ç¶™ç¶šãŒå¤§äº‹ã ï¼", 0.7),
                ],
            },
            timing_preferences: TimingPreferences {
                preferred_hours: vec![8, 10, 14, 16, 19], // ã‚ˆã‚Šç©æ¥µçš„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°
                max_daily_interventions: 8,
                min_interval_minutes: 90,
                ..Default::default()
            },
        }
    }
}
```

### 2.2 ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡Œå‹•æ¤œå‡ºã‚¨ãƒ³ã‚¸ãƒ³
```rust
pub struct ProactiveBehaviorDetector {
    user_patterns: UserBehaviorPatterns,
    current_context: CurrentContext,
    detection_rules: Vec<DetectionRule>,
    personality_strategy: PersonalityProactiveStrategy,
}

#[derive(Debug, Clone)]
pub struct UserBehaviorPatterns {
    pub work_hours: TimeRange,
    pub typical_task_duration: HashMap<String, Duration>,
    pub break_patterns: Vec<BreakPattern>,
    pub stress_indicators: Vec<StressIndicator>,
    pub motivation_cycles: MotivationPattern,
    pub sleep_schedule: SleepPattern,
}

#[derive(Debug, Clone)]
pub struct CurrentContext {
    pub current_time: DateTime<Utc>,
    pub active_tasks: Vec<Task>,
    pub recent_activity: Vec<UserActivity>,
    pub current_workload: WorkloadLevel,
    pub last_break: Option<DateTime<Utc>>,
    pub today_completion_rate: f32,
}

#[derive(Debug, Clone)]
pub struct DetectionRule {
    pub rule_id: String,
    pub event_type: ProactiveEventType,
    pub conditions: Vec<Condition>,
    pub priority: u8,
    pub cooldown_minutes: u32,
}

#[derive(Debug, Clone)]
pub enum ProactiveEventType {
    // ç”Ÿæ´»ãƒªã‚ºãƒ é–¢é€£ï¼ˆã‚¢ãƒ—ãƒªä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
    LateNightActivity,       // å¤œé…ã„ã‚¢ãƒ—ãƒªä½¿ç”¨
    EarlyMorningActivity,    // æ—©æœã‚¢ãƒ—ãƒªä½¿ç”¨
    HighTaskLoad,           // å¤§é‡ã®ã‚¿ã‚¹ã‚¯ç™»éŒ²
    FrequentChecking,       // é »ç¹ãªã‚¢ãƒ—ãƒªç¢ºèª
    
    // ã‚¿ã‚¹ã‚¯é–¢é€£
    TaskDelayed,            // ã‚¿ã‚¹ã‚¯é…å»¶
    TaskStuck,              // ã‚¿ã‚¹ã‚¯åœæ»
    DeadlineApproaching,    // ç· åˆ‡æ¥è¿‘
    
    // ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£
    LowMotivation,          // ä½ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
    HighStress,             // é«˜ã‚¹ãƒˆãƒ¬ã‚¹
    ProductivityDrop,       // ç”Ÿç”£æ€§ä½ä¸‹
    
    // ãƒã‚¸ãƒ†ã‚£ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆ
    GoodProgress,           // é †èª¿ãªé€²æ—
    TaskCompleted,          // ã‚¿ã‚¹ã‚¯å®Œäº†
    ProductivityImproved,   // ç”Ÿç”£æ€§å‘ä¸Š
    
    // ç›¸è«‡ãƒ»é›‘è«‡
    IdleTooLong,           // é•·æ™‚é–“ç„¡æ´»å‹•
    SeemsBored,            // é€€å±ˆãã†
    NeedsEncouragement,    // åŠ±ã¾ã—ãŒå¿…è¦
}

impl ProactiveBehaviorDetector {
    pub async fn detect_events(&self) -> Vec<ProactiveEvent> {
        let mut events = Vec::new();
        
        // å„æ¤œå‡ºãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œ
        for rule in &self.detection_rules {
            if self.evaluate_conditions(&rule.conditions) {
                events.push(ProactiveEvent {
                    event_type: rule.event_type.clone(),
                    priority: rule.priority,
                    detected_at: Utc::now(),
                    context: self.current_context.clone(),
                    rule_id: rule.rule_id.clone(),
                });
            }
        }
        
        // å„ªå…ˆåº¦ã¨ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        self.filter_events(events)
    }
    
    fn evaluate_conditions(&self, conditions: &[Condition]) -> bool {
        conditions.iter().all(|condition| {
            match condition {
                Condition::TimeRange(start, end) => {
                    let current_hour = self.current_context.current_time.hour();
                    current_hour >= *start && current_hour <= *end
                },
                Condition::WorkingTooLong(duration) => {
                    self.current_context.recent_activity
                        .iter()
                        .filter(|a| a.activity_type == ActivityType::TaskWork)
                        .map(|a| a.duration)
                        .sum::<Duration>() > *duration
                },
                Condition::TaskOverdue(days) => {
                    self.current_context.active_tasks
                        .iter()
                        .any(|t| t.is_overdue_by_days(*days))
                },
                Condition::LowCompletionRate(threshold) => {
                    self.current_context.today_completion_rate < *threshold
                },
                Condition::NoBreakSince(duration) => {
                    if let Some(last_break) = self.current_context.last_break {
                        Utc::now().signed_duration_since(last_break) > *duration
                    } else {
                        true
                    }
                },
                // ä»–ã®æ¡ä»¶...
            }
        })
    }
}
```

### 2.3 TaskNagå°‚ç”¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ
```rust
pub struct TaskNagMessageGenerator {
    personality_manager: Arc<PersonalityManager>,
    message_personalizer: MessagePersonalizer,
    context_aware_generator: ContextAwareGenerator,
}

#[derive(Debug, Clone)]
pub struct ProactiveMessage {
    pub message_type: ProactiveMessageType,
    pub content: String,
    pub tone: MessageTone,
    pub urgency: UrgencyLevel,
    pub suggested_actions: Vec<SuggestedAction>,
    pub follow_up_timing: Option<Duration>,
    pub personality_signature: String,
}

#[derive(Debug, Clone)]
pub enum ProactiveMessageType {
    // ä¸–è©±ç„¼ãç³»
    HealthConcern,          // å¥åº·å¿ƒé…
    WorkLifeBalance,        // ç”Ÿæ´»ãƒãƒ©ãƒ³ã‚¹
    GentleNagging,          // å„ªã—ã„å°è¨€
    
    // åŠ±ã¾ã—ç³»  
    Encouragement,          // åŠ±ã¾ã—
    Celebration,            // ãŠç¥ã„
    MotivationBoost,        // ã‚„ã‚‹æ°—ã‚¢ãƒƒãƒ—
    
    // ææ¡ˆç³»
    ProductivityTip,        // ç”Ÿç”£æ€§å‘ä¸Šææ¡ˆ
    TaskSuggestion,         // ã‚¿ã‚¹ã‚¯ææ¡ˆ
    BreakSuggestion,        // ä¼‘æ†©ææ¡ˆ
    
    // ç›¸è«‡ç³»
    CheckIn,                // æ§˜å­ä¼ºã„
    ConversationStarter,    // ä¼šè©±ã®ãã£ã‹ã‘
    ListeningEar,          // ç›¸è«‡å—ä»˜
}

impl TaskNagMessageGenerator {
    pub async fn generate_proactive_message(
        &self,
        event: &ProactiveEvent,
        user_context: &UserContext,
    ) -> Result<ProactiveMessage, MessageGenerationError> {
        // ç¾åœ¨ã®æ€§æ ¼ã‚’å–å¾—
        let personality = self.personality_manager.get_current_personality()
            .ok_or(MessageGenerationError::NoPersonality)?;
            
        // æ€§æ ¼åˆ¥æˆ¦ç•¥ã‚’å–å¾—
        let strategy = PersonalityProactiveStrategy::for_personality(&personality.id);
        
        // ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é¸æŠ
        let base_template = self.select_template(&event.event_type, &strategy)?;
        
        // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è€ƒæ…®ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
        let context_enhanced_message = self.context_aware_generator
            .enhance_with_context(base_template, user_context, event).await?;
            
        // æ€§æ ¼ç‰¹æ€§ã‚’é©ç”¨
        let personalized_message = self.message_personalizer
            .apply_personality(context_enhanced_message, personality)?;
            
        // ææ¡ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
        let suggested_actions = self.generate_suggested_actions(event, user_context)?;
        
        Ok(ProactiveMessage {
            message_type: self.determine_message_type(&event.event_type),
            content: personalized_message,
            tone: strategy.intervention_style.to_message_tone(),
            urgency: self.calculate_urgency(event),
            suggested_actions,
            follow_up_timing: self.calculate_follow_up_timing(event),
            personality_signature: personality.name.clone(),
        })
    }
    
    fn select_template(
        &self, 
        event_type: &ProactiveEventType, 
        strategy: &PersonalityProactiveStrategy
    ) -> Result<String, MessageGenerationError> {
        strategy.message_templates
            .get(event_type)
            .and_then(|templates| templates.choose(&mut rand::thread_rng()))
            .map(|template| template.content.clone())
            .ok_or(MessageGenerationError::NoTemplate)
    }
}
```

## 3. TaskNagç‹¬è‡ªé€šçŸ¥ä½“é¨“è¨­è¨ˆ

### 3.1 é€šçŸ¥è¡¨ç¤ºãƒ‘ã‚¿ãƒ¼ãƒ³
```
Pattern 1: ã•ã‚Šã’ãªã„æ°—é£ã„
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤— ãŠç¯€ä»‹ãªå¹¼é¦´æŸ“                  â”‚
â”‚                                     â”‚
â”‚ "ä»Šæ—¥ã¯ã‚¿ã‚¹ã‚¯ãŒãŸãã•ã‚“ã‚ã‚‹ã®ã­ã€œ   â”‚
â”‚  ç„¡ç†ã—ã¡ã‚ƒãƒ€ãƒ¡ã‚ˆï¼Ÿ                 â”‚
â”‚  ãŸã¾ã«ã¯ä¼‘æ†©ã‚‚å¤§äº‹ã ã‹ã‚‰ã­"        â”‚
â”‚                                     â”‚
â”‚         [ä¼‘æ†©ã™ã‚‹] [ã‚‚ã†å°‘ã—ç¶šã‘ã‚‹]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pattern 2: æ„›ã®ã‚ã‚‹å°è¨€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ˜¤ ãŠç¯€ä»‹ãªå¹¼é¦´æŸ“                  â”‚
â”‚                                     â”‚
â”‚ "ã‚ã®ãƒ¬ãƒãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯ã€              â”‚
â”‚  ã‚‚ã†3æ—¥ã‚‚æ‰‹ã¤ã‘ã¦ãªã„ã§ã—ã‚‡ï¼Ÿ      â”‚
â”‚  å¿ƒé…ã«ãªã£ã¡ã‚ƒã†ã‚ˆã€œ               â”‚
â”‚  ä»Šæ—¥å°‘ã—ã§ã‚‚ã‚„ã£ã¦ã¿ãªã„ï¼Ÿ"        â”‚
â”‚                                     â”‚
â”‚    [ä»Šã‚„ã‚‹] [æ˜æ—¥ã‚„ã‚‹] [è©±ã‚’èã„ã¦]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pattern 3: å¬‰ã—ã„å ±å‘Š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‰ ãŠç¯€ä»‹ãªå¹¼é¦´æŸ“                  â”‚
â”‚                                     â”‚
â”‚ "ã‚„ã£ãŸã˜ã‚ƒãªã„ï¼                   â”‚
â”‚  ä»Šé€±ã¯ã‚¿ã‚¹ã‚¯å®Œäº†ç‡80%ã‚ˆï¼          â”‚
â”‚  å…ˆé€±ã‚ˆã‚Š20%ã‚‚ä¸ŠãŒã£ã¦ã‚‹ã€œ          â”‚
â”‚  ã“ã®èª¿å­ã§ã„ã“ã†ã­ï¼"              â”‚
â”‚                                     â”‚
â”‚              [ã‚ã‚ŠãŒã¨ã†] [æ¬¡ã®ç›®æ¨™] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pattern 4: ç›¸è«‡ãƒ¢ãƒ¼ãƒ‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’­ ãŠç¯€ä»‹ãªå¹¼é¦´æŸ“                  â”‚
â”‚                                     â”‚
â”‚ "ãªã‚“ã‹ä»Šæ—¥ã€                       â”‚
â”‚  ã„ã¤ã‚‚ã‚ˆã‚Šå…ƒæ°—ãªã„ã¿ãŸã„...        â”‚
â”‚  ä½•ã‹å›°ã£ã¦ã‚‹ã“ã¨ã‚ã‚‹ï¼Ÿ             â”‚
â”‚  è‰¯ã‹ã£ãŸã‚‰è©±èãã‚ˆï¼Ÿ"              â”‚
â”‚                                     â”‚
â”‚      [è©±ã—ãŸã„] [å¤§ä¸ˆå¤«] [å¾Œã§è©±ã™]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 é€šçŸ¥ã‚¿ã‚¤ãƒŸãƒ³ã‚°æˆ¦ç•¥
```rust
pub struct NotificationTimingEngine {
    user_schedule: UserSchedule,
    interruption_cost_calculator: InterruptionCostCalculator,
    attention_window_detector: AttentionWindowDetector,
}

#[derive(Debug, Clone)]
pub struct OptimalTiming {
    pub ideal_time: DateTime<Utc>,
    pub window_start: DateTime<Utc>,
    pub window_end: DateTime<Utc>,
    pub interruption_cost: f32,    // 0.0-1.0 (ä½ã„ã»ã©è‰¯ã„)
    pub attention_score: f32,      // 0.0-1.0 (é«˜ã„ã»ã©è‰¯ã„)
    pub personality_alignment: f32, // æ€§æ ¼ã¨ã®é©åˆåº¦
}

impl NotificationTimingEngine {
    pub async fn find_optimal_timing(
        &self,
        message: &ProactiveMessage,
        user_context: &UserContext,
    ) -> OptimalTiming {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæ¥­ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
        let work_pattern = self.analyze_current_work_pattern(user_context);
        
        // ä¸­æ–­ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—
        let interruption_cost = self.interruption_cost_calculator
            .calculate_cost(&work_pattern);
            
        // æ³¨æ„åŠ›ã®çŠ¶æ…‹ã‚’æ¤œå‡º
        let attention_score = self.attention_window_detector
            .detect_attention_level(user_context);
            
        // æ€§æ ¼ã¨ã®é©åˆåº¦ãƒã‚§ãƒƒã‚¯
        let personality_alignment = self.check_personality_timing_alignment(message);
        
        // æœ€é©ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’æ±ºå®š
        self.calculate_optimal_window(
            interruption_cost,
            attention_score,
            personality_alignment
        )
    }
    
    fn analyze_current_work_pattern(&self, context: &UserContext) -> WorkPattern {
        match context.current_activity {
            Some(Activity::DeepWork) => WorkPattern::DeepFocus,
            Some(Activity::LightTask) => WorkPattern::LightWork,
            Some(Activity::Break) => WorkPattern::RestTime,
            None => WorkPattern::Idle,
        }
    }
}
```

### 3.3 ç›¸äº’ä½œç”¨ãƒ»å­¦ç¿’æ©Ÿèƒ½
```rust
pub struct ProactiveInteractionLearner {
    interaction_history: Vec<ProactiveInteraction>,
    effectiveness_tracker: EffectivenessTracker,
    personalization_engine: PersonalizationEngine,
}

#[derive(Debug, Clone)]
pub struct ProactiveInteraction {
    pub message_id: String,
    pub event_type: ProactiveEventType,
    pub personality_used: String,
    pub user_response: UserResponse,
    pub outcome: InteractionOutcome,
    pub timing_quality: f32,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub enum UserResponse {
    Positive(String),           // "ã‚ã‚ŠãŒã¨ã†"ã€"åŠ©ã‹ã£ãŸ"
    Neutral(String),            // "ã‚ã‹ã£ãŸ"ã€"å¾Œã§"
    Negative(String),           // "ã†ã‚‹ã•ã„"ã€"å¿™ã—ã„"
    ActionTaken(ActionType),    // å®Ÿéš›ã«ä¼‘æ†©ã—ãŸã€ã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ãŸ
    Ignored,                    // åå¿œãªã—
}

#[derive(Debug, Clone)]
pub enum InteractionOutcome {
    SuccessfulIntervention,     // å•é¡Œè§£æ±ºã«è²¢çŒ®
    TimingProblem,              // ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒæ‚ªã‹ã£ãŸ
    PersonalityMismatch,        // æ€§æ ¼ãŒåˆã‚ãªã‹ã£ãŸ
    OverIntervention,           // ä»‹å…¥ã—ã™ã
    UnderIntervention,          // ä»‹å…¥ä¸è¶³
}

impl ProactiveInteractionLearner {
    pub async fn learn_from_interaction(&mut self, interaction: ProactiveInteraction) {
        // åŠ¹æœæ¸¬å®š
        let effectiveness = self.effectiveness_tracker
            .measure_effectiveness(&interaction);
            
        // ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³èª¿æ•´
        self.personalization_engine
            .adjust_based_on_feedback(&interaction);
            
        // å±¥æ­´ã«è¨˜éŒ²
        self.interaction_history.push(interaction);
        
        // å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ›´æ–°
        self.update_learning_patterns().await;
    }
    
    pub fn get_personalization_suggestions(&self) -> PersonalizationSuggestions {
        PersonalizationSuggestions {
            preferred_timing_windows: self.extract_preferred_timings(),
            effective_message_types: self.identify_effective_messages(),
            personality_preferences: self.analyze_personality_preferences(),
            intervention_frequency: self.calculate_optimal_frequency(),
        }
    }
}
```

## 4. å®Ÿè£…ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 4.1 ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
```rust
pub struct TaskNagProactiveSystem {
    // ã‚³ã‚¢æ¤œå‡ºã‚¨ãƒ³ã‚¸ãƒ³
    behavior_detector: ProactiveBehaviorDetector,
    message_generator: TaskNagMessageGenerator,
    timing_engine: NotificationTimingEngine,
    
    // çµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    personality_manager: Arc<PersonalityManager>,
    context_collector: ContextCollector,
    interaction_learner: ProactiveInteractionLearner,
    
    // è¨­å®šãƒ»åˆ¶å¾¡
    user_preferences: ProactivePreferences,
    active_sessions: HashMap<String, ProactiveSession>,
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
    db: SqlitePool,
}

#[derive(Debug, Clone)]
pub struct ProactivePreferences {
    pub enabled: bool,
    pub max_daily_interventions: u32,
    pub quiet_hours: Vec<TimeRange>,
    pub preferred_intervention_types: Vec<ProactiveMessageType>,
    pub sensitivity_level: f32,  // 0.0-1.0
}

impl TaskNagProactiveSystem {
    pub async fn start_monitoring(&mut self) -> Result<(), ProactiveError> {
        // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã¨ã—ã¦ç›£è¦–é–‹å§‹
        let detector = self.behavior_detector.clone();
        let generator = self.message_generator.clone();
        let timing_engine = self.timing_engine.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_minutes(5));
            
            loop {
                interval.tick().await;
                
                // ã‚¤ãƒ™ãƒ³ãƒˆæ¤œå‡º
                if let Ok(events) = detector.detect_events().await {
                    for event in events {
                        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ
                        if let Ok(message) = generator.generate_proactive_message(&event, &user_context).await {
                            // æœ€é©ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨ˆç®—
                            let timing = timing_engine.find_optimal_timing(&message, &user_context).await;
                            
                            // é€šçŸ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
                            Self::schedule_notification(message, timing).await;
                        }
                    }
                }
            }
        });
        
        Ok(())
    }
}
```

### 4.2 Tauriçµ±åˆ
```rust
// Tauri Commands
#[tauri::command]
pub async fn enable_proactive_mode(
    system: tauri::State<'_, Mutex<TaskNagProactiveSystem>>,
    preferences: ProactivePreferences,
) -> Result<(), String> {
    let mut system = system.lock().await;
    system.user_preferences = preferences;
    system.start_monitoring().await.map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn respond_to_proactive_message(
    system: tauri::State<'_, Mutex<TaskNagProactiveSystem>>,
    message_id: String,
    response: UserResponse,
) -> Result<(), String> {
    let mut system = system.lock().await;
    system.record_user_response(message_id, response).await.map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_proactive_insights(
    system: tauri::State<'_, Mutex<TaskNagProactiveSystem>>,
) -> Result<ProactiveInsights, String> {
    let system = system.lock().await;
    Ok(system.generate_insights())
}
```

## 5. å®Ÿè£…è¨ˆç”»

### Phase 1: åŸºæœ¬æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ1é€±é–“ï¼‰
1. **ProactiveBehaviorDetector** ã®åŸºæœ¬å®Ÿè£…
2. **åŸºæœ¬çš„ãªæ¤œå‡ºãƒ«ãƒ¼ãƒ«**ï¼ˆå¤œæ›´ã‹ã—ã€é•·æ™‚é–“ä½œæ¥­ã€ã‚¿ã‚¹ã‚¯é…å»¶ï¼‰
3. **PersonalityManagerçµ±åˆ**

### Phase 2: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆï¼ˆ1é€±é–“ï¼‰
1. **TaskNagMessageGenerator** å®Ÿè£…
2. **æ€§æ ¼åˆ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**
3. **ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè€ƒæ…®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ**

### Phase 3: ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ»å­¦ç¿’ï¼ˆ1é€±é–“ï¼‰
1. **NotificationTimingEngine** å®Ÿè£…
2. **ProactiveInteractionLearner** åŸºæœ¬æ©Ÿèƒ½
3. **åŠ¹æœæ¸¬å®šãƒ»æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«**

### Phase 4: UIçµ±åˆãƒ»å®Œæˆï¼ˆ3æ—¥ï¼‰
1. **ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é€šçŸ¥UI**
2. **è¨­å®šç”»é¢**
3. **ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ†ã‚¹ãƒˆ**

## 6. æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

### ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®é©æ–°
- **èƒ½å‹•çš„ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼æ„Ÿ**: AIãŒæ°—ã«ã‹ã‘ã¦ãã‚Œã¦ã„ã‚‹å®Ÿæ„Ÿ
- **ç”Ÿæ´»ãƒªã‚ºãƒ æ”¹å–„**: å¥åº·çš„ãªä½œæ¥­ç¿’æ…£ã®å½¢æˆ
- **ã‚¹ãƒˆãƒ¬ã‚¹è»½æ¸›**: å•é¡Œã®æ—©æœŸç™ºè¦‹ãƒ»äºˆé˜²
- **ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ç¶­æŒ**: é©åˆ‡ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã®åŠ±ã¾ã—

### TaskNagã®å·®åˆ¥åŒ–
- **æ„Ÿæƒ…çš„ãªã¤ãªãŒã‚Š**: å˜ãªã‚‹ãƒ„ãƒ¼ãƒ«ã‹ã‚‰ç›¸æ£’ã¸
- **å€‹æ€§çš„ãªä½“é¨“**: æ€§æ ¼ã«ã‚ˆã‚‹å¤šæ§˜ãªé–¢ã‚ã‚Šæ–¹
- **æˆé•·ã‚’å…±æœ‰**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¤‰åŒ–ã‚’ä¸€ç·’ã«å–œã¶
- **äºˆé˜²çš„ã‚µãƒãƒ¼ãƒˆ**: å•é¡Œã«ãªã‚‹å‰ã®å¯¾å‡¦

ã“ã®ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€TaskNagã¯çœŸã«ã€Œå£ã†ã‚‹ã•ãã¦ä¸–è©±ç„¼ããªã€AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç”Ÿç”£æ€§å‘ä¸Šã¨å¹¸ç¦åº¦å‘ä¸Šã«è²¢çŒ®ã§ãã¾ã™ã€‚